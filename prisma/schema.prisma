// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  user
  consultant
  admin
}

enum ConsultantClientStatus {
  active
  inactive
}

enum ConsultantInviteStatus {
  pending
  accepted
  rejected
}

enum FixedIncomeType {
  CDB_PRE
  LC_PRE
  LCI_PRE
  LCA_PRE
  RDB_PRE
  LF_PRE
  LFS_PRE
  CRI_PRE
  CRA_PRE
  DPGE_PRE
  RDC_PRE
  LIG_PRE
}

enum FixedIncomeIndexer {
  PRE
  CDI
  IPCA
}

enum FixedIncomeLiquidity {
  DAILY
  MATURITY
}

model User {
  id                            String                       @id @default(uuid())
  email                         String                       @unique
  password                      String
  name                          String
  avatarUrl                     String?
  createdAt                     DateTime                     @default(now())
  updatedAt                     DateTime                     @updatedAt
  role                          UserRole                     @default(user)
  events                        Event[]
  dashboard                     DashboardData[]
  cashflows                     Cashflow[]
  cashflowGroups                CashflowGroup[]
  cashflowItems                 CashflowItem[]
  cashflowValues                CashflowValue[]
  consultantProfile             Consultant?
  consultancies                 ClientConsultant[]           @relation("ClientConsultantClients")
  // Stocks
  watchlists                    Watchlist[]
  portfolios                    Portfolio[]
  stockTransactions             StockTransaction[]
  fixedIncomeAssets             FixedIncomeAsset[]
  notifications                 Notification[]
  consultantInvites             ConsultantInvite[]           @relation("UserConsultantInvites")
  impersonationLogsAsConsultant ConsultantImpersonationLog[] @relation("ImpersonationLogConsultant")
  impersonationLogsAsClient     ConsultantImpersonationLog[] @relation("ImpersonationLogClient")
  alocacaoConfigs               AlocacaoConfig[]
}

model Consultant {
  id        String             @id @default(uuid())
  userId    String             @unique
  user      User               @relation(fields: [userId], references: [id])
  clients   ClientConsultant[]
  invites   ConsultantInvite[]
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
}

model ClientConsultant {
  id           String                 @id @default(uuid())
  consultantId String
  consultant   Consultant             @relation(fields: [consultantId], references: [id])
  clientId     String
  client       User                   @relation("ClientConsultantClients", fields: [clientId], references: [id])
  createdAt    DateTime               @default(now())
  status       ConsultantClientStatus @default(active)

  @@unique([consultantId, clientId])
  @@index([clientId])
}

model ConsultantInvite {
  id            String                 @id @default(uuid())
  consultantId  String
  consultant    Consultant             @relation(fields: [consultantId], references: [id])
  invitedUserId String?
  invitedUser   User?                  @relation("UserConsultantInvites", fields: [invitedUserId], references: [id])
  email         String
  status        ConsultantInviteStatus @default(pending)
  token         String                 @unique
  createdAt     DateTime               @default(now())
  respondedAt   DateTime?
  notifications Notification[]
}

model Notification {
  id        String            @id @default(uuid())
  userId    String
  user      User              @relation(fields: [userId], references: [id])
  title     String
  message   String
  type      String
  metadata  Json?
  readAt    DateTime?
  createdAt DateTime          @default(now())
  inviteId  String?
  invite    ConsultantInvite? @relation(fields: [inviteId], references: [id])

  @@index([userId, createdAt])
}

model Event {
  id     String   @id @default(uuid())
  title  String
  date   DateTime
  userId String
  user   User     @relation(fields: [userId], references: [id])
}

model DashboardData {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])
  metric String
  value  Float
}

model AlocacaoConfig {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  categoria String
  minimo    Float
  maximo    Float
  target    Float
  descricao String?  @default("")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, categoria])
  @@index([userId])
  @@map("alocacao_configs")
}

model Cashflow {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  data            DateTime
  tipo            String // "Receita" ou "Despesa"
  categoria       String
  descricao       String
  valor           Float
  forma_pagamento String
  pago            Boolean
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model CashflowGroup {
  id         String          @id @default(uuid())
  userId     String? // null se for grupo padrão (template)
  user       User?           @relation(fields: [userId], references: [id])
  name       String
  type       String // 'entrada', 'despesa' ou 'investimento'
  parentId   String? // FK para outro grupo (subgrupo)
  parent     CashflowGroup?  @relation("SubGroups", fields: [parentId], references: [id])
  children   CashflowGroup[] @relation("SubGroups")
  items      CashflowItem[]
  orderIndex Int             @default(0)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  @@index([userId])
  @@index([parentId])
}

model CashflowItem {
  id          String        @id @default(uuid())
  userId      String? // null se for item padrão (template)
  user        User?         @relation(fields: [userId], references: [id])
  groupId     String
  group       CashflowGroup @relation(fields: [groupId], references: [id])
  name        String
  significado String? // explicação opcional
  rank        String? // ordem de importância (essencial, normal, etc.)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  values CashflowValue[]

  @@index([groupId])
  @@index([userId])
}

model CashflowValue {
  id        String       @id @default(uuid())
  itemId    String
  item      CashflowItem @relation(fields: [itemId], references: [id])
  userId    String
  user      User         @relation(fields: [userId], references: [id])
  year      Int
  month     Int // 0 = Jan, 11 = Dez
  value     Float
  color     String? // Cor do texto (formato CSS: #000000, green, red, etc.)
  comment   String? // Comentário da célula
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([itemId, userId, year, month])
  @@index([itemId])
  @@index([userId])
}

// ===== STOCKS MODULE =====

// Ativo/Stock disponível na B3
model Stock {
  id          String   @id @default(uuid())
  ticker      String   @unique // Código do ativo (ex: PETR4, VALE3)
  companyName String // Nome da empresa
  sector      String? // Setor da empresa
  subsector   String? // Subsetor
  segment     String? // Segmento
  isActive    Boolean  @default(true)
  lastUpdate  DateTime @default(now())

  // Relacionamentos
  watchlists   Watchlist[]
  portfolios   Portfolio[]
  transactions StockTransaction[]

  @@map("stocks")
}

// Lista de observação do usuário
model Watchlist {
  id      String   @id @default(uuid())
  userId  String
  user    User     @relation(fields: [userId], references: [id])
  stockId String? // Pode ser null para compatibilidade
  stock   Stock?   @relation(fields: [stockId], references: [id])
  assetId String? // Nova referência para Asset
  asset   Asset?   @relation(fields: [assetId], references: [id])
  addedAt DateTime @default(now())
  notes   String? // Observações do usuário

  @@unique([userId, stockId])
  @@map("watchlists")
}

// Portfolio do usuário (ações que possui)
model Portfolio {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  stockId       String? // Pode ser null para compatibilidade
  stock         Stock?   @relation(fields: [stockId], references: [id])
  assetId       String? // Nova referência para Asset
  asset         Asset?   @relation(fields: [assetId], references: [id])
  quantity      Int // Quantidade de ações
  avgPrice      Float // Preço médio de compra
  totalInvested Float // Total investido
  objetivo      Float    @default(0) // Objetivo percentual do ativo
  estrategia    String? // Estratégia da ação: 'value', 'growth' ou 'risk'
  tipoFii       String? // Tipo do FII: 'fofi', 'tvm' ou 'tijolo'
  lastUpdate    DateTime @default(now())

  @@unique([userId, stockId])
  @@unique([userId, assetId])
  @@map("portfolios")
}

// Histórico de transações (compras e vendas)
model StockTransaction {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  stockId   String? // Pode ser null para compatibilidade
  stock     Stock?   @relation(fields: [stockId], references: [id])
  assetId   String? // Nova referência para Asset
  asset     Asset?   @relation(fields: [assetId], references: [id])
  type      String // "compra" ou "venda"
  quantity  Int // Quantidade de ações
  price     Float // Preço por ação
  total     Float // Valor total da transação
  date      DateTime // Data da transação
  fees      Float? // Taxas da operação
  notes     String? // Observações
  createdAt DateTime @default(now())

  @@map("stock_transactions")
}

// ===== EXTERNAL DATA MODELS =====

// Ativos consolidados (ações, FII, ETF, BDR, REIT, criptos, etc.)
model Asset {
  id             String    @id @default(uuid())
  symbol         String    @unique // Código do ativo (ex: PETR4, VALE3, BTC, ETH)
  name           String // Nome do ativo (ex: Petrobras PN, Vale ON, Bitcoin)
  type           String // Tipo: "stock", "etf", "fii", "bdr", "crypto"
  currency       String // Moeda: "BRL", "USD"
  source         String    @default("brapi") // Fonte dos dados
  currentPrice   Decimal?  @db.Decimal(10, 6) // Preço atual (atualizado pelo cron)
  priceUpdatedAt DateTime? // Data da última atualização de preço
  updatedAt      DateTime  @updatedAt

  // Relacionamentos
  watchlists        Watchlist[]
  portfolios        Portfolio[]
  transactions      StockTransaction[]
  fixedIncomeAsset  FixedIncomeAsset?
  priceHistory      AssetPriceHistory[]

  @@index([symbol])
  @@index([type])
  @@index([source])
  @@map("assets")
}

// Histórico de preços dos ativos (persistido pelo cron, lido pelas telas)
model AssetPriceHistory {
  id        String   @id @default(uuid())
  assetId   String
  symbol    String
  price     Decimal  @db.Decimal(10, 6)
  currency  String?
  source    String   @default("BRAPI")
  date      DateTime // Data de referência (normalizada para início do dia)
  createdAt DateTime @default(now())

  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  @@unique([symbol, date])
  @@index([symbol, date])
  @@index([symbol])
  @@index([date])
  @@map("asset_price_history")
}

// Log opcional de execução do sync de preços
model SyncPriceLog {
  id            String   @id @default(uuid())
  totalUpdated  Int      @default(0)
  totalInserted Int      @default(0)
  errors        Int      @default(0)
  duration      Int      // segundos
  executedAt    DateTime @default(now())

  @@index([executedAt])
  @@map("sync_price_logs")
}

model FixedIncomeAsset {
  id             String                @id @default(uuid())
  userId         String
  user           User                  @relation(fields: [userId], references: [id])
  assetId        String                @unique
  asset          Asset                 @relation(fields: [assetId], references: [id])
  type           FixedIncomeType
  description    String
  startDate      DateTime
  maturityDate   DateTime
  investedAmount Float
  annualRate     Float
  indexer        FixedIncomeIndexer?
  indexerPercent Float?
  liquidityType  FixedIncomeLiquidity?
  taxExempt      Boolean               @default(false)
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  @@index([userId])
  @@index([assetId])
  @@map("fixed_income_assets")
}

// Enum para status das instituições
enum InstitutionStatus {
  ATIVA
  INATIVA
}

// Instituições financeiras (corretoras e bancos de investimento)
model Institution {
  id        String            @id @default(cuid())
  codigo    String            @unique // Código identificador da instituição
  nome      String // Nome da instituição
  cnpj      String? // CNPJ da instituição (opcional)
  status    InstitutionStatus @default(ATIVA)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@index([codigo])
  @@index([cnpj])
  @@index([status])
  @@map("institutions")
}

model ConsultantImpersonationLog {
  id           String   @id @default(uuid())
  consultantId String
  consultant   User     @relation("ImpersonationLogConsultant", fields: [consultantId], references: [id])
  clientId     String
  client       User     @relation("ImpersonationLogClient", fields: [clientId], references: [id])
  action       String
  details      Json
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([consultantId])
  @@index([clientId])
  @@index([createdAt])
  @@index([action])
  @@map("consultant_impersonation_logs")
}

// ===== ECONOMIC INDEXES MODULE =====

model EconomicIndex {
  id         String   @id @default(uuid())
  indexType  String   // "CDI" | "IPCA"
  date       DateTime // Data de referência
  value      Decimal  @db.Decimal(10, 6) // Taxa do período (decimal para precisão)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([indexType, date])
  @@index([indexType])
  @@index([date])
  @@index([indexType, date])
  @@map("economic_indexes")
}

// Cache de indicadores de mercado (IBOV, Dólar, BTC, ETH)
// Banco primeiro, fallback BRAPI quando cache expirado
model MarketIndicatorCache {
  id            String   @id @default(uuid())
  indicatorKey  String   @unique // "IBOV" | "USD-BRL" | "BTC" | "ETH"
  price         Decimal  @db.Decimal(18, 4)
  changePercent Decimal? @db.Decimal(10, 4)
  updatedAt     DateTime @updatedAt

  @@map("market_indicator_cache")
}
